# coding: utf-8

"""
    Wyscout API (v4)

    [Customer resources](https://www.hudl.com/support/wyscout) | [Customer support](https://www.hudl.com/support/contact)  [Wyscout Data resources](https://footballdata.wyscout.com/resources/)  **IMPORTANT: Version switching planned for July 20th 2021.**  On July 20th 2021 we will switch v3 as the Current version. V2 will become Legacy.  Please see [Versioning](#section/Versioning) section for any related details.  # Overview  This is the product documentation for our API service, in which you can find all definitions and technical information you may need.  # Authentication  ## Overview  This page explain how to authenticate to Wyscout APIs using Basic Access Authentication.  ## Using your client software  Depending on your client software you should be provided with a mechanism for supplying an username and password: that will build the required authentication headers automatically.  For example you can specify the -u argument with curl as username:password.  ## Supplying Basic Access Authentication headers  It is possible to construct the authentication headers manually:  * Build a string of the form username:password. * Encode the string in Base64 * Supply an `Authorization` header with content `Basic` followed by the encoded string.   For example, the string `Aladdin:OpenSesame` encodes to `QWxhZGRpbjpPcGVuU2VzYW1l` in base64,   so you would use this string `Authorization: Basic QWxhZGRpbjpPcGVuU2VzYW1l`  ## Rate limits  To avoid services overload requests are rate limited. The Wyscout API currently enforces a limit of **12** request per second per API Key.  If the rate limit is exceeded, the API will return the following HTTP 429 response:  ```json   {     \"error\": {       \"code\": 429,       \"message\": \"Too many requests\"     }   } ```  # Data glossary and definitions  At the following link you can find our Data Glossary that describes events, metrics and concepts used across the Wyscout API, Platform and reports.  <a href=\"https://dataglossary.wyscout.com/\" target=\"_blank\">Wyscout Data Glossary</a>   ## Pitch coordinates  ![Pitch map](assets/images/WyscoutDataCoordinates.png)  The event's coordinates depends on the subject. The subject's goal to be defended is always **x=0%** and the attack is always **x=100%**. All values are % expressed as **(x,y)**.  # Versioning  Wyscout gives you the chance to choose between three different sets of API endpoints.  ## Current The latest available version. It includes the most recent endpoints and improvements.  ## Preview The beta version of our next official release. Here we start to implement future improvements and new endpoints.  ## Legacy The old version. This is still available and running, in order to let users adapt their tools to new ones.  ## Version Switch  Wyscout will constantly improve its dataset by adding new endpoints and improving the existing ones. “Preview” version is where you can find last delivered updates. When a new and improved “Current” version is released, the previous version becomes “Legacy” – which means it will not immediately cease to exist, giving you the time to adapt your systems. It will be available and running until another new version – “Current” – is released, at least six months after the previous one.  ![Version Switch](assets/images/WyscoutVersionSwitch.png)  Documentation on [apidocs.wyscout.com](apidocs.wyscout.com) will always be available also for “Legacy” version. Each version will receive support as from the following table:  ![Version Support](assets/images/WyscoutVersionSupport.png)

    The version of the OpenAPI document: 2024-05-09T09:09:27Z
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.player import Player
from typing import Optional, Set
from typing_extensions import Self

class PlayersListInner(BaseModel):
    """
    PlayersListInner
    """ # noqa: E501
    player: Optional[Player] = None
    player_id: Optional[StrictInt] = Field(default=None, alias="playerId")
    position: Optional[StrictStr] = Field(default=None, description="<table><thead><tr><th>Name</th><th>Code</th></tr></thead><tbody><tr><td>Goalkeeper</td><td>gk</td></tr><tr><td>Right Back</td><td>rb</td></tr><tr><td>Right Centre Back</td><td>rcb</td></tr><tr><td>Left Centre Back</td><td>lcb</td></tr><tr><td>Left Back</td><td>lb</td></tr><tr><td>Right Winger</td><td>rw</td></tr><tr><td>Right Centre Midfielder</td><td>rcmf</td></tr><tr><td>Left Centre Midfielder</td><td>lcmf</td></tr><tr><td>Left Winger</td><td>lw</td></tr><tr><td>Second Striker</td><td>ss</td></tr><tr><td>Striker</td><td>cf</td></tr><tr><td>Attacking Midfielder</td><td>amf</td></tr><tr><td>Right Centre Midfielder</td><td>rcmf3</td></tr><tr><td>Defensive Midfielder</td><td>dmf</td></tr><tr><td>Left Centre Midfielder</td><td>lcmf3</td></tr><tr><td>Right Defensive Midfielder</td><td>rdmf</td></tr><tr><td>Left Defensive Midfielder</td><td>ldmf</td></tr><tr><td>Right Attacking Midfielder</td><td>ramf</td></tr><tr><td>Left Attacking Midfielder</td><td>lamf</td></tr><tr><td>Right Wing Forward</td><td>rwf</td></tr><tr><td>Left Wing Forward</td><td>lwf</td></tr><tr><td>Right Centre Back (3 at the back)</td><td>rcb3</td></tr><tr><td>Centre Back</td><td>cb</td></tr><tr><td>Left Centre Back (3 at the back)</td><td>lcb3</td></tr><tr><td>Right Wingback</td><td>rwb</td></tr><tr><td>Left Wingback</td><td>lwb</td></tr><tr><td>Right Back (5 at the back)</td><td>rb5</td></tr><tr><td>Left Back (5 at the back)</td><td>lb5</td></tr></tbody></table>")
    __properties: ClassVar[List[str]] = ["player", "playerId", "position"]

    @field_validator('position')
    def position_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['gk', 'rb', 'rcb', 'lcb', 'lb', 'rw', 'rcmf', 'lcmf', 'lw', 'ss', 'cf', 'amf', 'rcmf3', 'dmf', 'lcmf3', 'rdmf', 'ldmf', 'ramf', 'lamf', 'rwf', 'lwf', 'rcb3', 'cb', 'lcb3', 'rwb', 'lwb', 'rb5', 'lb5']):
            raise ValueError("must be one of enum values ('gk', 'rb', 'rcb', 'lcb', 'lb', 'rw', 'rcmf', 'lcmf', 'lw', 'ss', 'cf', 'amf', 'rcmf3', 'dmf', 'lcmf3', 'rdmf', 'ldmf', 'ramf', 'lamf', 'rwf', 'lwf', 'rcb3', 'cb', 'lcb3', 'rwb', 'lwb', 'rb5', 'lb5')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PlayersListInner from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of player
        if self.player:
            _dict['player'] = self.player.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PlayersListInner from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "player": Player.from_dict(obj["player"]) if obj.get("player") is not None else None,
            "playerId": obj.get("playerId"),
            "position": obj.get("position")
        })
        return _obj


