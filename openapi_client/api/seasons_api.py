# coding: utf-8

"""
    Wyscout API (v4)

    [Customer resources](https://www.hudl.com/support/wyscout) | [Customer support](https://www.hudl.com/support/contact)  [Wyscout Data resources](https://footballdata.wyscout.com/resources/)  **IMPORTANT: Version switching planned for July 20th 2021.**  On July 20th 2021 we will switch v3 as the Current version. V2 will become Legacy.  Please see [Versioning](#section/Versioning) section for any related details.  # Overview  This is the product documentation for our API service, in which you can find all definitions and technical information you may need.  # Authentication  ## Overview  This page explain how to authenticate to Wyscout APIs using Basic Access Authentication.  ## Using your client software  Depending on your client software you should be provided with a mechanism for supplying an username and password: that will build the required authentication headers automatically.  For example you can specify the -u argument with curl as username:password.  ## Supplying Basic Access Authentication headers  It is possible to construct the authentication headers manually:  * Build a string of the form username:password. * Encode the string in Base64 * Supply an `Authorization` header with content `Basic` followed by the encoded string.   For example, the string `Aladdin:OpenSesame` encodes to `QWxhZGRpbjpPcGVuU2VzYW1l` in base64,   so you would use this string `Authorization: Basic QWxhZGRpbjpPcGVuU2VzYW1l`  ## Rate limits  To avoid services overload requests are rate limited. The Wyscout API currently enforces a limit of **12** request per second per API Key.  If the rate limit is exceeded, the API will return the following HTTP 429 response:  ```json   {     \"error\": {       \"code\": 429,       \"message\": \"Too many requests\"     }   } ```  # Data glossary and definitions  At the following link you can find our Data Glossary that describes events, metrics and concepts used across the Wyscout API, Platform and reports.  <a href=\"https://dataglossary.wyscout.com/\" target=\"_blank\">Wyscout Data Glossary</a>   ## Pitch coordinates  ![Pitch map](assets/images/WyscoutDataCoordinates.png)  The event's coordinates depends on the subject. The subject's goal to be defended is always **x=0%** and the attack is always **x=100%**. All values are % expressed as **(x,y)**.  # Versioning  Wyscout gives you the chance to choose between three different sets of API endpoints.  ## Current The latest available version. It includes the most recent endpoints and improvements.  ## Preview The beta version of our next official release. Here we start to implement future improvements and new endpoints.  ## Legacy The old version. This is still available and running, in order to let users adapt their tools to new ones.  ## Version Switch  Wyscout will constantly improve its dataset by adding new endpoints and improving the existing ones. “Preview” version is where you can find last delivered updates. When a new and improved “Current” version is released, the previous version becomes “Legacy” – which means it will not immediately cease to exist, giving you the time to adapt your systems. It will be available and running until another new version – “Current” – is released, at least six months after the previous one.  ![Version Switch](assets/images/WyscoutVersionSwitch.png)  Documentation on [apidocs.wyscout.com](apidocs.wyscout.com) will always be available also for “Legacy” version. Each version will receive support as from the following table:  ![Version Support](assets/images/WyscoutVersionSupport.png)

    The version of the OpenAPI document: 2024-05-09T09:09:27Z
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictStr
from typing import Optional
from typing_extensions import Annotated
from openapi_client.models.season import Season
from openapi_client.models.season_assistmen import SeasonAssistmen
from openapi_client.models.season_career import SeasonCareer
from openapi_client.models.season_fixtures import SeasonFixtures
from openapi_client.models.season_matches import SeasonMatches
from openapi_client.models.season_players import SeasonPlayers
from openapi_client.models.season_scorers import SeasonScorers
from openapi_client.models.season_standings import SeasonStandings
from openapi_client.models.season_teams import SeasonTeams
from openapi_client.models.season_transfers import SeasonTransfers

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class SeasonsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def seasons_wy_id_assistmen_get(
        self,
        wy_id: Annotated[StrictStr, Field(description="Relevant content id")],
        fetch: Annotated[Optional[StrictStr], Field(description="List of related objects to be fetched, separated by comma: `season`, `competition`")] = None,
        details: Annotated[Optional[StrictStr], Field(description="List of related objects to be detailed, separated by comma: `players`, `teams`")] = None,
        authorization: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SeasonAssistmen:
        """Season assistmen

        Returns info about the given season assistmen

        :param wy_id: Relevant content id (required)
        :type wy_id: str
        :param fetch: List of related objects to be fetched, separated by comma: `season`, `competition`
        :type fetch: str
        :param details: List of related objects to be detailed, separated by comma: `players`, `teams`
        :type details: str
        :param authorization:
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._seasons_wy_id_assistmen_get_serialize(
            wy_id=wy_id,
            fetch=fetch,
            details=details,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SeasonAssistmen",
            '400': "ErrorCode400",
            '429': "ErrorCode429",
            '500': "ErrorCode500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def seasons_wy_id_assistmen_get_with_http_info(
        self,
        wy_id: Annotated[StrictStr, Field(description="Relevant content id")],
        fetch: Annotated[Optional[StrictStr], Field(description="List of related objects to be fetched, separated by comma: `season`, `competition`")] = None,
        details: Annotated[Optional[StrictStr], Field(description="List of related objects to be detailed, separated by comma: `players`, `teams`")] = None,
        authorization: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SeasonAssistmen]:
        """Season assistmen

        Returns info about the given season assistmen

        :param wy_id: Relevant content id (required)
        :type wy_id: str
        :param fetch: List of related objects to be fetched, separated by comma: `season`, `competition`
        :type fetch: str
        :param details: List of related objects to be detailed, separated by comma: `players`, `teams`
        :type details: str
        :param authorization:
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._seasons_wy_id_assistmen_get_serialize(
            wy_id=wy_id,
            fetch=fetch,
            details=details,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SeasonAssistmen",
            '400': "ErrorCode400",
            '429': "ErrorCode429",
            '500': "ErrorCode500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def seasons_wy_id_assistmen_get_without_preload_content(
        self,
        wy_id: Annotated[StrictStr, Field(description="Relevant content id")],
        fetch: Annotated[Optional[StrictStr], Field(description="List of related objects to be fetched, separated by comma: `season`, `competition`")] = None,
        details: Annotated[Optional[StrictStr], Field(description="List of related objects to be detailed, separated by comma: `players`, `teams`")] = None,
        authorization: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Season assistmen

        Returns info about the given season assistmen

        :param wy_id: Relevant content id (required)
        :type wy_id: str
        :param fetch: List of related objects to be fetched, separated by comma: `season`, `competition`
        :type fetch: str
        :param details: List of related objects to be detailed, separated by comma: `players`, `teams`
        :type details: str
        :param authorization:
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._seasons_wy_id_assistmen_get_serialize(
            wy_id=wy_id,
            fetch=fetch,
            details=details,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SeasonAssistmen",
            '400': "ErrorCode400",
            '429': "ErrorCode429",
            '500': "ErrorCode500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _seasons_wy_id_assistmen_get_serialize(
        self,
        wy_id,
        fetch,
        details,
        authorization,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if wy_id is not None:
            _path_params['wyId'] = wy_id
        # process the query parameters
        if fetch is not None:
            
            _query_params.append(('fetch', fetch))
            
        if details is not None:
            
            _query_params.append(('details', details))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/seasons/{wyId}/assistmen',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def seasons_wy_id_career_get(
        self,
        wy_id: Annotated[StrictStr, Field(description="Relevant content id")],
        fetch: Annotated[Optional[StrictStr], Field(description="List of related objects to be fetched, separated by comma: `competition`, `season`")] = None,
        details: Annotated[Optional[StrictStr], Field(description="List of related objects to be detailed, separated by comma: `team`, `round`")] = None,
        filters: Annotated[Optional[StrictStr], Field(description="<table><thead><tr><th>Object</th><th>Description</th></tr></thead><tbody><tr><td>gameWeek</td><td>If present, it returns standings for that gameweek</td></tr><tr><td>gameWeekInterval</td><td>If present, it returns standings for that gameweeks’ range Use: {\"gameWeekInterval\":{\"startWeek\":7,\"endWeek\":12}}</td></tr></tbody></table>")] = None,
        authorization: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SeasonCareer:
        """Seasons career

        Returns general performance information about all the teams for the given season

        :param wy_id: Relevant content id (required)
        :type wy_id: str
        :param fetch: List of related objects to be fetched, separated by comma: `competition`, `season`
        :type fetch: str
        :param details: List of related objects to be detailed, separated by comma: `team`, `round`
        :type details: str
        :param filters: <table><thead><tr><th>Object</th><th>Description</th></tr></thead><tbody><tr><td>gameWeek</td><td>If present, it returns standings for that gameweek</td></tr><tr><td>gameWeekInterval</td><td>If present, it returns standings for that gameweeks’ range Use: {\"gameWeekInterval\":{\"startWeek\":7,\"endWeek\":12}}</td></tr></tbody></table>
        :type filters: str
        :param authorization:
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._seasons_wy_id_career_get_serialize(
            wy_id=wy_id,
            fetch=fetch,
            details=details,
            filters=filters,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SeasonCareer",
            '400': "ErrorCode400",
            '429': "ErrorCode429",
            '500': "ErrorCode500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def seasons_wy_id_career_get_with_http_info(
        self,
        wy_id: Annotated[StrictStr, Field(description="Relevant content id")],
        fetch: Annotated[Optional[StrictStr], Field(description="List of related objects to be fetched, separated by comma: `competition`, `season`")] = None,
        details: Annotated[Optional[StrictStr], Field(description="List of related objects to be detailed, separated by comma: `team`, `round`")] = None,
        filters: Annotated[Optional[StrictStr], Field(description="<table><thead><tr><th>Object</th><th>Description</th></tr></thead><tbody><tr><td>gameWeek</td><td>If present, it returns standings for that gameweek</td></tr><tr><td>gameWeekInterval</td><td>If present, it returns standings for that gameweeks’ range Use: {\"gameWeekInterval\":{\"startWeek\":7,\"endWeek\":12}}</td></tr></tbody></table>")] = None,
        authorization: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SeasonCareer]:
        """Seasons career

        Returns general performance information about all the teams for the given season

        :param wy_id: Relevant content id (required)
        :type wy_id: str
        :param fetch: List of related objects to be fetched, separated by comma: `competition`, `season`
        :type fetch: str
        :param details: List of related objects to be detailed, separated by comma: `team`, `round`
        :type details: str
        :param filters: <table><thead><tr><th>Object</th><th>Description</th></tr></thead><tbody><tr><td>gameWeek</td><td>If present, it returns standings for that gameweek</td></tr><tr><td>gameWeekInterval</td><td>If present, it returns standings for that gameweeks’ range Use: {\"gameWeekInterval\":{\"startWeek\":7,\"endWeek\":12}}</td></tr></tbody></table>
        :type filters: str
        :param authorization:
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._seasons_wy_id_career_get_serialize(
            wy_id=wy_id,
            fetch=fetch,
            details=details,
            filters=filters,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SeasonCareer",
            '400': "ErrorCode400",
            '429': "ErrorCode429",
            '500': "ErrorCode500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def seasons_wy_id_career_get_without_preload_content(
        self,
        wy_id: Annotated[StrictStr, Field(description="Relevant content id")],
        fetch: Annotated[Optional[StrictStr], Field(description="List of related objects to be fetched, separated by comma: `competition`, `season`")] = None,
        details: Annotated[Optional[StrictStr], Field(description="List of related objects to be detailed, separated by comma: `team`, `round`")] = None,
        filters: Annotated[Optional[StrictStr], Field(description="<table><thead><tr><th>Object</th><th>Description</th></tr></thead><tbody><tr><td>gameWeek</td><td>If present, it returns standings for that gameweek</td></tr><tr><td>gameWeekInterval</td><td>If present, it returns standings for that gameweeks’ range Use: {\"gameWeekInterval\":{\"startWeek\":7,\"endWeek\":12}}</td></tr></tbody></table>")] = None,
        authorization: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Seasons career

        Returns general performance information about all the teams for the given season

        :param wy_id: Relevant content id (required)
        :type wy_id: str
        :param fetch: List of related objects to be fetched, separated by comma: `competition`, `season`
        :type fetch: str
        :param details: List of related objects to be detailed, separated by comma: `team`, `round`
        :type details: str
        :param filters: <table><thead><tr><th>Object</th><th>Description</th></tr></thead><tbody><tr><td>gameWeek</td><td>If present, it returns standings for that gameweek</td></tr><tr><td>gameWeekInterval</td><td>If present, it returns standings for that gameweeks’ range Use: {\"gameWeekInterval\":{\"startWeek\":7,\"endWeek\":12}}</td></tr></tbody></table>
        :type filters: str
        :param authorization:
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._seasons_wy_id_career_get_serialize(
            wy_id=wy_id,
            fetch=fetch,
            details=details,
            filters=filters,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SeasonCareer",
            '400': "ErrorCode400",
            '429': "ErrorCode429",
            '500': "ErrorCode500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _seasons_wy_id_career_get_serialize(
        self,
        wy_id,
        fetch,
        details,
        filters,
        authorization,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if wy_id is not None:
            _path_params['wyId'] = wy_id
        # process the query parameters
        if fetch is not None:
            
            _query_params.append(('fetch', fetch))
            
        if details is not None:
            
            _query_params.append(('details', details))
            
        if filters is not None:
            
            _query_params.append(('filters', filters))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/seasons/{wyId}/career',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def seasons_wy_id_fixtures_get(
        self,
        wy_id: Annotated[StrictStr, Field(description="Relevant content id")],
        to_date: Annotated[Optional[StrictStr], Field(description="Ending date in YYYY-MM-DD format")] = None,
        fetch: Annotated[Optional[StrictStr], Field(description="List of related objects to be fetched, separated by comma: `season`")] = None,
        details: Annotated[Optional[StrictStr], Field(description="List of related objects to be detailed, separated by comma: `matches`, `players`, `teams`")] = None,
        from_date: Annotated[Optional[StrictStr], Field(description="Starting date in YYYY-MM-DD format")] = None,
        authorization: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SeasonFixtures:
        """Seasons fixtures

        Retrieves all the matches for the given season

        :param wy_id: Relevant content id (required)
        :type wy_id: str
        :param to_date: Ending date in YYYY-MM-DD format
        :type to_date: str
        :param fetch: List of related objects to be fetched, separated by comma: `season`
        :type fetch: str
        :param details: List of related objects to be detailed, separated by comma: `matches`, `players`, `teams`
        :type details: str
        :param from_date: Starting date in YYYY-MM-DD format
        :type from_date: str
        :param authorization:
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._seasons_wy_id_fixtures_get_serialize(
            wy_id=wy_id,
            to_date=to_date,
            fetch=fetch,
            details=details,
            from_date=from_date,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SeasonFixtures",
            '400': "ErrorCode400",
            '429': "ErrorCode429",
            '500': "ErrorCode500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def seasons_wy_id_fixtures_get_with_http_info(
        self,
        wy_id: Annotated[StrictStr, Field(description="Relevant content id")],
        to_date: Annotated[Optional[StrictStr], Field(description="Ending date in YYYY-MM-DD format")] = None,
        fetch: Annotated[Optional[StrictStr], Field(description="List of related objects to be fetched, separated by comma: `season`")] = None,
        details: Annotated[Optional[StrictStr], Field(description="List of related objects to be detailed, separated by comma: `matches`, `players`, `teams`")] = None,
        from_date: Annotated[Optional[StrictStr], Field(description="Starting date in YYYY-MM-DD format")] = None,
        authorization: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SeasonFixtures]:
        """Seasons fixtures

        Retrieves all the matches for the given season

        :param wy_id: Relevant content id (required)
        :type wy_id: str
        :param to_date: Ending date in YYYY-MM-DD format
        :type to_date: str
        :param fetch: List of related objects to be fetched, separated by comma: `season`
        :type fetch: str
        :param details: List of related objects to be detailed, separated by comma: `matches`, `players`, `teams`
        :type details: str
        :param from_date: Starting date in YYYY-MM-DD format
        :type from_date: str
        :param authorization:
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._seasons_wy_id_fixtures_get_serialize(
            wy_id=wy_id,
            to_date=to_date,
            fetch=fetch,
            details=details,
            from_date=from_date,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SeasonFixtures",
            '400': "ErrorCode400",
            '429': "ErrorCode429",
            '500': "ErrorCode500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def seasons_wy_id_fixtures_get_without_preload_content(
        self,
        wy_id: Annotated[StrictStr, Field(description="Relevant content id")],
        to_date: Annotated[Optional[StrictStr], Field(description="Ending date in YYYY-MM-DD format")] = None,
        fetch: Annotated[Optional[StrictStr], Field(description="List of related objects to be fetched, separated by comma: `season`")] = None,
        details: Annotated[Optional[StrictStr], Field(description="List of related objects to be detailed, separated by comma: `matches`, `players`, `teams`")] = None,
        from_date: Annotated[Optional[StrictStr], Field(description="Starting date in YYYY-MM-DD format")] = None,
        authorization: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Seasons fixtures

        Retrieves all the matches for the given season

        :param wy_id: Relevant content id (required)
        :type wy_id: str
        :param to_date: Ending date in YYYY-MM-DD format
        :type to_date: str
        :param fetch: List of related objects to be fetched, separated by comma: `season`
        :type fetch: str
        :param details: List of related objects to be detailed, separated by comma: `matches`, `players`, `teams`
        :type details: str
        :param from_date: Starting date in YYYY-MM-DD format
        :type from_date: str
        :param authorization:
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._seasons_wy_id_fixtures_get_serialize(
            wy_id=wy_id,
            to_date=to_date,
            fetch=fetch,
            details=details,
            from_date=from_date,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SeasonFixtures",
            '400': "ErrorCode400",
            '429': "ErrorCode429",
            '500': "ErrorCode500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _seasons_wy_id_fixtures_get_serialize(
        self,
        wy_id,
        to_date,
        fetch,
        details,
        from_date,
        authorization,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if wy_id is not None:
            _path_params['wyId'] = wy_id
        # process the query parameters
        if to_date is not None:
            
            _query_params.append(('toDate', to_date))
            
        if fetch is not None:
            
            _query_params.append(('fetch', fetch))
            
        if details is not None:
            
            _query_params.append(('details', details))
            
        if from_date is not None:
            
            _query_params.append(('fromDate', from_date))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/seasons/{wyId}/fixtures',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def seasons_wy_id_get(
        self,
        wy_id: Annotated[StrictStr, Field(description="Relevant content id")],
        details: Annotated[Optional[StrictStr], Field(description="List of related objects to be detailed, separated by comma: `competition`")] = None,
        authorization: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Season:
        """Season details

        Returns info about the given season

        :param wy_id: Relevant content id (required)
        :type wy_id: str
        :param details: List of related objects to be detailed, separated by comma: `competition`
        :type details: str
        :param authorization:
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._seasons_wy_id_get_serialize(
            wy_id=wy_id,
            details=details,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Season",
            '400': "ErrorCode400",
            '429': "ErrorCode429",
            '500': "ErrorCode500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def seasons_wy_id_get_with_http_info(
        self,
        wy_id: Annotated[StrictStr, Field(description="Relevant content id")],
        details: Annotated[Optional[StrictStr], Field(description="List of related objects to be detailed, separated by comma: `competition`")] = None,
        authorization: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Season]:
        """Season details

        Returns info about the given season

        :param wy_id: Relevant content id (required)
        :type wy_id: str
        :param details: List of related objects to be detailed, separated by comma: `competition`
        :type details: str
        :param authorization:
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._seasons_wy_id_get_serialize(
            wy_id=wy_id,
            details=details,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Season",
            '400': "ErrorCode400",
            '429': "ErrorCode429",
            '500': "ErrorCode500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def seasons_wy_id_get_without_preload_content(
        self,
        wy_id: Annotated[StrictStr, Field(description="Relevant content id")],
        details: Annotated[Optional[StrictStr], Field(description="List of related objects to be detailed, separated by comma: `competition`")] = None,
        authorization: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Season details

        Returns info about the given season

        :param wy_id: Relevant content id (required)
        :type wy_id: str
        :param details: List of related objects to be detailed, separated by comma: `competition`
        :type details: str
        :param authorization:
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._seasons_wy_id_get_serialize(
            wy_id=wy_id,
            details=details,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Season",
            '400': "ErrorCode400",
            '429': "ErrorCode429",
            '500': "ErrorCode500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _seasons_wy_id_get_serialize(
        self,
        wy_id,
        details,
        authorization,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if wy_id is not None:
            _path_params['wyId'] = wy_id
        # process the query parameters
        if details is not None:
            
            _query_params.append(('details', details))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/seasons/{wyId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def seasons_wy_id_matches_get(
        self,
        wy_id: Annotated[StrictStr, Field(description="Relevant content id")],
        fetch: Annotated[Optional[StrictStr], Field(description="List of related objects to be fetched, separated by comma: `season`")] = None,
        authorization: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SeasonMatches:
        """Seasons matches

        Returns the list of matches played in the given season

        :param wy_id: Relevant content id (required)
        :type wy_id: str
        :param fetch: List of related objects to be fetched, separated by comma: `season`
        :type fetch: str
        :param authorization:
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._seasons_wy_id_matches_get_serialize(
            wy_id=wy_id,
            fetch=fetch,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SeasonMatches",
            '400': "ErrorCode400",
            '429': "ErrorCode429",
            '500': "ErrorCode500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def seasons_wy_id_matches_get_with_http_info(
        self,
        wy_id: Annotated[StrictStr, Field(description="Relevant content id")],
        fetch: Annotated[Optional[StrictStr], Field(description="List of related objects to be fetched, separated by comma: `season`")] = None,
        authorization: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SeasonMatches]:
        """Seasons matches

        Returns the list of matches played in the given season

        :param wy_id: Relevant content id (required)
        :type wy_id: str
        :param fetch: List of related objects to be fetched, separated by comma: `season`
        :type fetch: str
        :param authorization:
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._seasons_wy_id_matches_get_serialize(
            wy_id=wy_id,
            fetch=fetch,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SeasonMatches",
            '400': "ErrorCode400",
            '429': "ErrorCode429",
            '500': "ErrorCode500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def seasons_wy_id_matches_get_without_preload_content(
        self,
        wy_id: Annotated[StrictStr, Field(description="Relevant content id")],
        fetch: Annotated[Optional[StrictStr], Field(description="List of related objects to be fetched, separated by comma: `season`")] = None,
        authorization: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Seasons matches

        Returns the list of matches played in the given season

        :param wy_id: Relevant content id (required)
        :type wy_id: str
        :param fetch: List of related objects to be fetched, separated by comma: `season`
        :type fetch: str
        :param authorization:
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._seasons_wy_id_matches_get_serialize(
            wy_id=wy_id,
            fetch=fetch,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SeasonMatches",
            '400': "ErrorCode400",
            '429': "ErrorCode429",
            '500': "ErrorCode500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _seasons_wy_id_matches_get_serialize(
        self,
        wy_id,
        fetch,
        authorization,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if wy_id is not None:
            _path_params['wyId'] = wy_id
        # process the query parameters
        if fetch is not None:
            
            _query_params.append(('fetch', fetch))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/seasons/{wyId}/matches',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def seasons_wy_id_players_get(
        self,
        wy_id: Annotated[StrictStr, Field(description="Relevant content id")],
        count: Annotated[Optional[StrictStr], Field(description="Alias for limit argument")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="Allows to change the number of results for page (limited to max 100 results for single page)")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Allows to sort resultset by given field and directions")] = None,
        authorization: Optional[StrictStr] = None,
        fetch: Annotated[Optional[StrictStr], Field(description="List of related objects to be fetched, separated by comma: `season`")] = None,
        page: Annotated[Optional[StrictStr], Field(description="Allows to change page (current page) from which the results are fetched")] = None,
        search: Annotated[Optional[StrictStr], Field(description="Allows to simple search and filter resultset by OR condition among defined search fields")] = None,
        details: Annotated[Optional[StrictStr], Field(description="List of related objects to be detailed, separated by comma: `currentTeam`")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Allows to simple filter resultset by AND and EQUAL condition on given field")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SeasonPlayers:
        """Seasons players

        Returns the list of players who have played in the given season

        :param wy_id: Relevant content id (required)
        :type wy_id: str
        :param count: Alias for limit argument
        :type count: str
        :param limit: Allows to change the number of results for page (limited to max 100 results for single page)
        :type limit: str
        :param sort: Allows to sort resultset by given field and directions
        :type sort: str
        :param authorization:
        :type authorization: str
        :param fetch: List of related objects to be fetched, separated by comma: `season`
        :type fetch: str
        :param page: Allows to change page (current page) from which the results are fetched
        :type page: str
        :param search: Allows to simple search and filter resultset by OR condition among defined search fields
        :type search: str
        :param details: List of related objects to be detailed, separated by comma: `currentTeam`
        :type details: str
        :param filter: Allows to simple filter resultset by AND and EQUAL condition on given field
        :type filter: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._seasons_wy_id_players_get_serialize(
            wy_id=wy_id,
            count=count,
            limit=limit,
            sort=sort,
            authorization=authorization,
            fetch=fetch,
            page=page,
            search=search,
            details=details,
            filter=filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SeasonPlayers",
            '400': "ErrorCode400",
            '429': "ErrorCode429",
            '500': "ErrorCode500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def seasons_wy_id_players_get_with_http_info(
        self,
        wy_id: Annotated[StrictStr, Field(description="Relevant content id")],
        count: Annotated[Optional[StrictStr], Field(description="Alias for limit argument")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="Allows to change the number of results for page (limited to max 100 results for single page)")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Allows to sort resultset by given field and directions")] = None,
        authorization: Optional[StrictStr] = None,
        fetch: Annotated[Optional[StrictStr], Field(description="List of related objects to be fetched, separated by comma: `season`")] = None,
        page: Annotated[Optional[StrictStr], Field(description="Allows to change page (current page) from which the results are fetched")] = None,
        search: Annotated[Optional[StrictStr], Field(description="Allows to simple search and filter resultset by OR condition among defined search fields")] = None,
        details: Annotated[Optional[StrictStr], Field(description="List of related objects to be detailed, separated by comma: `currentTeam`")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Allows to simple filter resultset by AND and EQUAL condition on given field")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SeasonPlayers]:
        """Seasons players

        Returns the list of players who have played in the given season

        :param wy_id: Relevant content id (required)
        :type wy_id: str
        :param count: Alias for limit argument
        :type count: str
        :param limit: Allows to change the number of results for page (limited to max 100 results for single page)
        :type limit: str
        :param sort: Allows to sort resultset by given field and directions
        :type sort: str
        :param authorization:
        :type authorization: str
        :param fetch: List of related objects to be fetched, separated by comma: `season`
        :type fetch: str
        :param page: Allows to change page (current page) from which the results are fetched
        :type page: str
        :param search: Allows to simple search and filter resultset by OR condition among defined search fields
        :type search: str
        :param details: List of related objects to be detailed, separated by comma: `currentTeam`
        :type details: str
        :param filter: Allows to simple filter resultset by AND and EQUAL condition on given field
        :type filter: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._seasons_wy_id_players_get_serialize(
            wy_id=wy_id,
            count=count,
            limit=limit,
            sort=sort,
            authorization=authorization,
            fetch=fetch,
            page=page,
            search=search,
            details=details,
            filter=filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SeasonPlayers",
            '400': "ErrorCode400",
            '429': "ErrorCode429",
            '500': "ErrorCode500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def seasons_wy_id_players_get_without_preload_content(
        self,
        wy_id: Annotated[StrictStr, Field(description="Relevant content id")],
        count: Annotated[Optional[StrictStr], Field(description="Alias for limit argument")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="Allows to change the number of results for page (limited to max 100 results for single page)")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Allows to sort resultset by given field and directions")] = None,
        authorization: Optional[StrictStr] = None,
        fetch: Annotated[Optional[StrictStr], Field(description="List of related objects to be fetched, separated by comma: `season`")] = None,
        page: Annotated[Optional[StrictStr], Field(description="Allows to change page (current page) from which the results are fetched")] = None,
        search: Annotated[Optional[StrictStr], Field(description="Allows to simple search and filter resultset by OR condition among defined search fields")] = None,
        details: Annotated[Optional[StrictStr], Field(description="List of related objects to be detailed, separated by comma: `currentTeam`")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Allows to simple filter resultset by AND and EQUAL condition on given field")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Seasons players

        Returns the list of players who have played in the given season

        :param wy_id: Relevant content id (required)
        :type wy_id: str
        :param count: Alias for limit argument
        :type count: str
        :param limit: Allows to change the number of results for page (limited to max 100 results for single page)
        :type limit: str
        :param sort: Allows to sort resultset by given field and directions
        :type sort: str
        :param authorization:
        :type authorization: str
        :param fetch: List of related objects to be fetched, separated by comma: `season`
        :type fetch: str
        :param page: Allows to change page (current page) from which the results are fetched
        :type page: str
        :param search: Allows to simple search and filter resultset by OR condition among defined search fields
        :type search: str
        :param details: List of related objects to be detailed, separated by comma: `currentTeam`
        :type details: str
        :param filter: Allows to simple filter resultset by AND and EQUAL condition on given field
        :type filter: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._seasons_wy_id_players_get_serialize(
            wy_id=wy_id,
            count=count,
            limit=limit,
            sort=sort,
            authorization=authorization,
            fetch=fetch,
            page=page,
            search=search,
            details=details,
            filter=filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SeasonPlayers",
            '400': "ErrorCode400",
            '429': "ErrorCode429",
            '500': "ErrorCode500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _seasons_wy_id_players_get_serialize(
        self,
        wy_id,
        count,
        limit,
        sort,
        authorization,
        fetch,
        page,
        search,
        details,
        filter,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if wy_id is not None:
            _path_params['wyId'] = wy_id
        # process the query parameters
        if count is not None:
            
            _query_params.append(('count', count))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if fetch is not None:
            
            _query_params.append(('fetch', fetch))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if search is not None:
            
            _query_params.append(('search', search))
            
        if details is not None:
            
            _query_params.append(('details', details))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/seasons/{wyId}/players',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def seasons_wy_id_scorers_get(
        self,
        wy_id: Annotated[StrictStr, Field(description="Relevant content id")],
        fetch: Annotated[Optional[StrictStr], Field(description="List of related objects to be fetched, separated by comma: `season`, `competition`")] = None,
        details: Annotated[Optional[StrictStr], Field(description="List of related objects to be detailed, separated by comma: `players`, `teams`")] = None,
        authorization: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SeasonScorers:
        """Season scorers

        Returns info about the given season scorers

        :param wy_id: Relevant content id (required)
        :type wy_id: str
        :param fetch: List of related objects to be fetched, separated by comma: `season`, `competition`
        :type fetch: str
        :param details: List of related objects to be detailed, separated by comma: `players`, `teams`
        :type details: str
        :param authorization:
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._seasons_wy_id_scorers_get_serialize(
            wy_id=wy_id,
            fetch=fetch,
            details=details,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SeasonScorers",
            '400': "ErrorCode400",
            '429': "ErrorCode429",
            '500': "ErrorCode500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def seasons_wy_id_scorers_get_with_http_info(
        self,
        wy_id: Annotated[StrictStr, Field(description="Relevant content id")],
        fetch: Annotated[Optional[StrictStr], Field(description="List of related objects to be fetched, separated by comma: `season`, `competition`")] = None,
        details: Annotated[Optional[StrictStr], Field(description="List of related objects to be detailed, separated by comma: `players`, `teams`")] = None,
        authorization: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SeasonScorers]:
        """Season scorers

        Returns info about the given season scorers

        :param wy_id: Relevant content id (required)
        :type wy_id: str
        :param fetch: List of related objects to be fetched, separated by comma: `season`, `competition`
        :type fetch: str
        :param details: List of related objects to be detailed, separated by comma: `players`, `teams`
        :type details: str
        :param authorization:
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._seasons_wy_id_scorers_get_serialize(
            wy_id=wy_id,
            fetch=fetch,
            details=details,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SeasonScorers",
            '400': "ErrorCode400",
            '429': "ErrorCode429",
            '500': "ErrorCode500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def seasons_wy_id_scorers_get_without_preload_content(
        self,
        wy_id: Annotated[StrictStr, Field(description="Relevant content id")],
        fetch: Annotated[Optional[StrictStr], Field(description="List of related objects to be fetched, separated by comma: `season`, `competition`")] = None,
        details: Annotated[Optional[StrictStr], Field(description="List of related objects to be detailed, separated by comma: `players`, `teams`")] = None,
        authorization: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Season scorers

        Returns info about the given season scorers

        :param wy_id: Relevant content id (required)
        :type wy_id: str
        :param fetch: List of related objects to be fetched, separated by comma: `season`, `competition`
        :type fetch: str
        :param details: List of related objects to be detailed, separated by comma: `players`, `teams`
        :type details: str
        :param authorization:
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._seasons_wy_id_scorers_get_serialize(
            wy_id=wy_id,
            fetch=fetch,
            details=details,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SeasonScorers",
            '400': "ErrorCode400",
            '429': "ErrorCode429",
            '500': "ErrorCode500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _seasons_wy_id_scorers_get_serialize(
        self,
        wy_id,
        fetch,
        details,
        authorization,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if wy_id is not None:
            _path_params['wyId'] = wy_id
        # process the query parameters
        if fetch is not None:
            
            _query_params.append(('fetch', fetch))
            
        if details is not None:
            
            _query_params.append(('details', details))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/seasons/{wyId}/scorers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def seasons_wy_id_standings_get(
        self,
        wy_id: Annotated[StrictStr, Field(description="Relevant content id")],
        round_id: Annotated[Optional[StrictStr], Field(description="Relevant round id")] = None,
        fetch: Annotated[Optional[StrictStr], Field(description="List of related objects to be fetched, separated by comma: `competition`, `season`")] = None,
        details: Annotated[Optional[StrictStr], Field(description="List of related objects to be detailed, separated by comma: `teams`")] = None,
        authorization: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SeasonStandings:
        """Seasons standings

        Returns the standings for the given season

        :param wy_id: Relevant content id (required)
        :type wy_id: str
        :param round_id: Relevant round id
        :type round_id: str
        :param fetch: List of related objects to be fetched, separated by comma: `competition`, `season`
        :type fetch: str
        :param details: List of related objects to be detailed, separated by comma: `teams`
        :type details: str
        :param authorization:
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._seasons_wy_id_standings_get_serialize(
            wy_id=wy_id,
            round_id=round_id,
            fetch=fetch,
            details=details,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SeasonStandings",
            '400': "ErrorCode400",
            '429': "ErrorCode429",
            '500': "ErrorCode500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def seasons_wy_id_standings_get_with_http_info(
        self,
        wy_id: Annotated[StrictStr, Field(description="Relevant content id")],
        round_id: Annotated[Optional[StrictStr], Field(description="Relevant round id")] = None,
        fetch: Annotated[Optional[StrictStr], Field(description="List of related objects to be fetched, separated by comma: `competition`, `season`")] = None,
        details: Annotated[Optional[StrictStr], Field(description="List of related objects to be detailed, separated by comma: `teams`")] = None,
        authorization: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SeasonStandings]:
        """Seasons standings

        Returns the standings for the given season

        :param wy_id: Relevant content id (required)
        :type wy_id: str
        :param round_id: Relevant round id
        :type round_id: str
        :param fetch: List of related objects to be fetched, separated by comma: `competition`, `season`
        :type fetch: str
        :param details: List of related objects to be detailed, separated by comma: `teams`
        :type details: str
        :param authorization:
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._seasons_wy_id_standings_get_serialize(
            wy_id=wy_id,
            round_id=round_id,
            fetch=fetch,
            details=details,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SeasonStandings",
            '400': "ErrorCode400",
            '429': "ErrorCode429",
            '500': "ErrorCode500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def seasons_wy_id_standings_get_without_preload_content(
        self,
        wy_id: Annotated[StrictStr, Field(description="Relevant content id")],
        round_id: Annotated[Optional[StrictStr], Field(description="Relevant round id")] = None,
        fetch: Annotated[Optional[StrictStr], Field(description="List of related objects to be fetched, separated by comma: `competition`, `season`")] = None,
        details: Annotated[Optional[StrictStr], Field(description="List of related objects to be detailed, separated by comma: `teams`")] = None,
        authorization: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Seasons standings

        Returns the standings for the given season

        :param wy_id: Relevant content id (required)
        :type wy_id: str
        :param round_id: Relevant round id
        :type round_id: str
        :param fetch: List of related objects to be fetched, separated by comma: `competition`, `season`
        :type fetch: str
        :param details: List of related objects to be detailed, separated by comma: `teams`
        :type details: str
        :param authorization:
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._seasons_wy_id_standings_get_serialize(
            wy_id=wy_id,
            round_id=round_id,
            fetch=fetch,
            details=details,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SeasonStandings",
            '400': "ErrorCode400",
            '429': "ErrorCode429",
            '500': "ErrorCode500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _seasons_wy_id_standings_get_serialize(
        self,
        wy_id,
        round_id,
        fetch,
        details,
        authorization,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if wy_id is not None:
            _path_params['wyId'] = wy_id
        # process the query parameters
        if round_id is not None:
            
            _query_params.append(('roundId', round_id))
            
        if fetch is not None:
            
            _query_params.append(('fetch', fetch))
            
        if details is not None:
            
            _query_params.append(('details', details))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/seasons/{wyId}/standings',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def seasons_wy_id_teams_get(
        self,
        wy_id: Annotated[StrictStr, Field(description="Relevant content id")],
        fetch: Annotated[Optional[StrictStr], Field(description="List of related objects to be fetched, separated by comma: `season`")] = None,
        authorization: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SeasonTeams:
        """Seasons teams

        Returns the list of teams in the given season. Please note: the call returns only the teams that already played at least one match in the season.

        :param wy_id: Relevant content id (required)
        :type wy_id: str
        :param fetch: List of related objects to be fetched, separated by comma: `season`
        :type fetch: str
        :param authorization:
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._seasons_wy_id_teams_get_serialize(
            wy_id=wy_id,
            fetch=fetch,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SeasonTeams",
            '400': "ErrorCode400",
            '429': "ErrorCode429",
            '500': "ErrorCode500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def seasons_wy_id_teams_get_with_http_info(
        self,
        wy_id: Annotated[StrictStr, Field(description="Relevant content id")],
        fetch: Annotated[Optional[StrictStr], Field(description="List of related objects to be fetched, separated by comma: `season`")] = None,
        authorization: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SeasonTeams]:
        """Seasons teams

        Returns the list of teams in the given season. Please note: the call returns only the teams that already played at least one match in the season.

        :param wy_id: Relevant content id (required)
        :type wy_id: str
        :param fetch: List of related objects to be fetched, separated by comma: `season`
        :type fetch: str
        :param authorization:
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._seasons_wy_id_teams_get_serialize(
            wy_id=wy_id,
            fetch=fetch,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SeasonTeams",
            '400': "ErrorCode400",
            '429': "ErrorCode429",
            '500': "ErrorCode500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def seasons_wy_id_teams_get_without_preload_content(
        self,
        wy_id: Annotated[StrictStr, Field(description="Relevant content id")],
        fetch: Annotated[Optional[StrictStr], Field(description="List of related objects to be fetched, separated by comma: `season`")] = None,
        authorization: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Seasons teams

        Returns the list of teams in the given season. Please note: the call returns only the teams that already played at least one match in the season.

        :param wy_id: Relevant content id (required)
        :type wy_id: str
        :param fetch: List of related objects to be fetched, separated by comma: `season`
        :type fetch: str
        :param authorization:
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._seasons_wy_id_teams_get_serialize(
            wy_id=wy_id,
            fetch=fetch,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SeasonTeams",
            '400': "ErrorCode400",
            '429': "ErrorCode429",
            '500': "ErrorCode500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _seasons_wy_id_teams_get_serialize(
        self,
        wy_id,
        fetch,
        authorization,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if wy_id is not None:
            _path_params['wyId'] = wy_id
        # process the query parameters
        if fetch is not None:
            
            _query_params.append(('fetch', fetch))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/seasons/{wyId}/teams',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def seasons_wy_id_transfers_get(
        self,
        wy_id: Annotated[StrictStr, Field(description="Relevant content id")],
        to_date: Annotated[Optional[StrictStr], Field(description="Ending date in YYYY-MM-DD format")] = None,
        details: Annotated[Optional[StrictStr], Field(description="List of related objects to be detailed, separated by comma: `teams`, `player`")] = None,
        from_date: Annotated[Optional[StrictStr], Field(description="Starting date in YYYY-MM-DD format")] = None,
        authorization: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SeasonTransfers:
        """Seasons transfers

        Retrieves all the transfer's information for the given season

        :param wy_id: Relevant content id (required)
        :type wy_id: str
        :param to_date: Ending date in YYYY-MM-DD format
        :type to_date: str
        :param details: List of related objects to be detailed, separated by comma: `teams`, `player`
        :type details: str
        :param from_date: Starting date in YYYY-MM-DD format
        :type from_date: str
        :param authorization:
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._seasons_wy_id_transfers_get_serialize(
            wy_id=wy_id,
            to_date=to_date,
            details=details,
            from_date=from_date,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SeasonTransfers",
            '400': "ErrorCode400",
            '429': "ErrorCode429",
            '500': "ErrorCode500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def seasons_wy_id_transfers_get_with_http_info(
        self,
        wy_id: Annotated[StrictStr, Field(description="Relevant content id")],
        to_date: Annotated[Optional[StrictStr], Field(description="Ending date in YYYY-MM-DD format")] = None,
        details: Annotated[Optional[StrictStr], Field(description="List of related objects to be detailed, separated by comma: `teams`, `player`")] = None,
        from_date: Annotated[Optional[StrictStr], Field(description="Starting date in YYYY-MM-DD format")] = None,
        authorization: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SeasonTransfers]:
        """Seasons transfers

        Retrieves all the transfer's information for the given season

        :param wy_id: Relevant content id (required)
        :type wy_id: str
        :param to_date: Ending date in YYYY-MM-DD format
        :type to_date: str
        :param details: List of related objects to be detailed, separated by comma: `teams`, `player`
        :type details: str
        :param from_date: Starting date in YYYY-MM-DD format
        :type from_date: str
        :param authorization:
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._seasons_wy_id_transfers_get_serialize(
            wy_id=wy_id,
            to_date=to_date,
            details=details,
            from_date=from_date,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SeasonTransfers",
            '400': "ErrorCode400",
            '429': "ErrorCode429",
            '500': "ErrorCode500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def seasons_wy_id_transfers_get_without_preload_content(
        self,
        wy_id: Annotated[StrictStr, Field(description="Relevant content id")],
        to_date: Annotated[Optional[StrictStr], Field(description="Ending date in YYYY-MM-DD format")] = None,
        details: Annotated[Optional[StrictStr], Field(description="List of related objects to be detailed, separated by comma: `teams`, `player`")] = None,
        from_date: Annotated[Optional[StrictStr], Field(description="Starting date in YYYY-MM-DD format")] = None,
        authorization: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Seasons transfers

        Retrieves all the transfer's information for the given season

        :param wy_id: Relevant content id (required)
        :type wy_id: str
        :param to_date: Ending date in YYYY-MM-DD format
        :type to_date: str
        :param details: List of related objects to be detailed, separated by comma: `teams`, `player`
        :type details: str
        :param from_date: Starting date in YYYY-MM-DD format
        :type from_date: str
        :param authorization:
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._seasons_wy_id_transfers_get_serialize(
            wy_id=wy_id,
            to_date=to_date,
            details=details,
            from_date=from_date,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SeasonTransfers",
            '400': "ErrorCode400",
            '429': "ErrorCode429",
            '500': "ErrorCode500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _seasons_wy_id_transfers_get_serialize(
        self,
        wy_id,
        to_date,
        details,
        from_date,
        authorization,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if wy_id is not None:
            _path_params['wyId'] = wy_id
        # process the query parameters
        if to_date is not None:
            
            _query_params.append(('toDate', to_date))
            
        if details is not None:
            
            _query_params.append(('details', details))
            
        if from_date is not None:
            
            _query_params.append(('fromDate', from_date))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/seasons/{wyId}/transfers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


